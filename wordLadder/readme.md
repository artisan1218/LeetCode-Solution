# Word Ladder problem
![image](https://user-images.githubusercontent.com/25105806/153682419-9c33d192-cbb7-4987-a945-e8c1900b871c.png)

Leetcode Link: https://leetcode.com/problems/word-ladder/

<br />

### Approach 1: BFS, ladderLengthBFS()
Credit to: https://www.youtube.com/watch?v=h9iTnkgv05E

Because we're calculating the shortest path, we can think of BFS as the basic structure of this solution. We can convert the problem to graph by building an edge between two words if and only if they differ exactly one character. So before going to BFS, we need to first find an efficient way to calculating the adjacent words(those who differ exactly 1 character) for each word in `wordList`. 

The way we did this is to find all patterns of each word. The dict `adjDict` stores every possible pattern of each word as key and the corresponding words as value. The patterns are generated by replacing each character in a word to a wildcard operator one by one and see if the resulting pattern can match any of the word in `wordList`. 

For example: `'*ot': ['hot', 'dot', 'lot']`

Next step is to use BFS to explore the graph and find the minimum path length. We will explore using BFS level by level, each level represents one more path length to the result. 

```python3
def ladderLengthBFS(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    if endWord not in wordList:
        return 0
    else:
        # creating adjDictacency list
        # adjDict stores every possible pattern of each word as key and the corresponding word as value
        adjDict = dict()
        wordList.append(beginWord)
        for word in wordList:
            for i in range(len(word)):
                pattern = word[:i] + '*' + word[i+1:] # pattern = '*ot', 'h*t' and 'ho*' for word 'hot'
                if pattern not in adjDict:
                    adjDict[pattern] = [word]
                else:
                    adjDict[pattern].append(word)

        # BFS
        visited = set([beginWord]) # we begin with beginWord
        queue = [beginWord]
        result = 1 
        while queue:
            # explore the graph level by level
            for _ in range(len(queue)):
                word = queue.pop(0)
                if word == endWord:
                    return result
                else:
                    # get all patterns of this word and check for its neighbors
                    for i in range(len(word)):
                        pattern = word[:i] + '*' + word[i+1:]
                        for neighbor in adjDict.get(pattern, []):
                            if neighbor not in visited:
                                queue.append(neighbor)
                                visited.add(neighbor)
            result += 1 # we increment the path length counter by 1 only after we've explored the entire level
        return 0
```

The graph generated by BFS is shown as:

For beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]

<img src="https://user-images.githubusercontent.com/25105806/153683333-c7e0e36e-fb85-4cf4-9c26-501e40eb52f2.jpg" width="50%" height="50%">


Time complexity is O(nm^2) where n is the number of words in `wordList` and m is the number of possible patterns. n\*m is the max number of edges we need to explore, m is the number of neighbor we need to find for each word:\
![image](https://user-images.githubusercontent.com/25105806/153684157-1898fa41-651e-43fc-aacd-78284d8280ce.png)


<br />

### Approach 2: Bidirectional BFS, ladderLengthBiBFS()

