# Word Ladder problem
![image](https://user-images.githubusercontent.com/25105806/153682419-9c33d192-cbb7-4987-a945-e8c1900b871c.png)

Leetcode Link: https://leetcode.com/problems/word-ladder/

<br />

### Approach 1: BFS, ladderLengthBFS()
Credit to: https://www.youtube.com/watch?v=h9iTnkgv05E

Because we're calculating the shortest path, we can think of BFS as the basic structure of this solution. We can convert the problem to graph by building an edge between two words if and only if they differ exactly one character. So before going to BFS, we need to first find an efficient way to calculating the adjacent words(those who differ exactly 1 character) for each word in `wordList`. 

The way we did this is to find all patterns of each word. The dict `adjDict` stores every possible pattern of each word as key and the corresponding words as value. The patterns are generated by replacing each character in a word to a wildcard operator one by one and see if the resulting pattern can match any of the word in `wordList`. 

For example: `'*ot': ['hot', 'dot', 'lot']`

Next step is to use BFS to explore the graph and find the minimum path length. We will explore using BFS level by level, each level represents one more path length to the result. 

```python3
def ladderLengthBFS(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    if endWord not in wordList:
        return 0
    else:
        # creating adjDictacency list
        # adjDict stores every possible pattern of each word as key and the corresponding word as value
        adjDict = dict()
        wordList.append(beginWord)
        for word in wordList:
            for i in range(len(word)):
                pattern = word[:i] + '*' + word[i+1:] # pattern = '*ot', 'h*t' and 'ho*' for word 'hot'
                if pattern not in adjDict:
                    adjDict[pattern] = [word]
                else:
                    adjDict[pattern].append(word)

        # BFS
        visited = set([beginWord]) # we begin with beginWord
        queue = [beginWord]
        result = 1 
        while queue:
            # explore the graph level by level
            for _ in range(len(queue)):
                word = queue.pop(0)
                if word == endWord:
                    return result
                else:
                    # get all patterns of this word and check for its neighbors
                    for i in range(len(word)):
                        pattern = word[:i] + '*' + word[i+1:]
                        for neighbor in adjDict.get(pattern, []):
                            if neighbor not in visited:
                                queue.append(neighbor)
                                visited.add(neighbor)
            result += 1 # we increment the path length counter by 1 only after we've explored the entire level
        return 0
```

The graph generated by BFS is shown as:

For beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]

<img src="https://user-images.githubusercontent.com/25105806/153683333-c7e0e36e-fb85-4cf4-9c26-501e40eb52f2.jpg" width="50%" height="50%">


Time complexity is O(nm^2) where n is the number of words in `wordList` and m is the number of possible patterns. n\*m is the max number of edges we need to explore, m is the number of neighbor we need to find for each word:\
![image](https://user-images.githubusercontent.com/25105806/153684157-1898fa41-651e-43fc-aacd-78284d8280ce.png)


<br />

### Approach 2: Bidirectional BFS, ladderLengthBiBFS()
Reference: https://leetcode.com/problems/word-ladder/discuss/40711/Two-end-BFS-in-Java-31ms and https://leetcode-cn.com/problems/word-ladder/solution/suan-fa-shi-xian-he-you-hua-javashuang-xiang-bfs23/

The idae as bidirectional BFS is to search from the `beginWord` and `endWord` at the same time. We will find the shortest path when two end overlaps with each other. 
```
"The idea behind bidirectional search is to run two simultaneous searches—one forward from
the initial state and the other backward from the goal—hoping that the two searches meet in
the middle. The motivation is that b^(d/2) + b^(d/2) is much less than b^d. b is branch factor, d is depth. "

----- section 3.4.6 in Artificial Intelligence - A modern approach by Stuart Russel and Peter Norvig
```

```python3
def ladderLengthBiBFS(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    if endWord not in wordList:
        return 0
    else:
        wordList.append(beginWord)
        # creating adjDictacency list
        # adjDict stores every possible pattern of each word as key and the corresponding word as value
        adjDict = dict()
        wordList.append(beginWord)
        for word in wordList:
            for i in range(len(word)):
                pattern = word[:i] + '*' + word[i+1:] # pattern = '*ot', 'h*t' and 'ho*' for word 'hot'
                if pattern not in adjDict:
                    adjDict[pattern] = [word]
                else:
                    adjDict[pattern].append(word)

        # Bidirectional BFS
        beginVisited, endVisited = set([beginWord]), set([endWord])
        beginQ, endQ = [beginWord], [endWord]
        result = 1
        while beginQ and endQ:
            # always search from the end with fewer explored node
            # beginQ always represent the queue with fewer node, not necessarily the top-down queue
            if len(beginQ) > len(endQ):
                beginQ, endQ = endQ, beginQ
                beginVisited, endVisited = endVisited, beginVisited

            # explore the graph level by level
            for _ in range(len(beginQ)):
                word = beginQ.pop(0)
                for i in range(len(word)):
                    pattern = word[:i] + '*' + word[i+1:]
                    for neighbor in adjDict.get(pattern, []):
                        # both visited sets have this node, which means we've reached an overlapping word
                        # we can simply return the result
                        if neighbor in endVisited:
                            return result + 1

                        if neighbor not in beginVisited:
                            beginVisited.add(neighbor)
                            beginQ.append(neighbor)
            result += 1
        return 0
```

The image below shows the time complexity difference between BFS and bidirectional BFS:\
<img src="https://user-images.githubusercontent.com/25105806/153685293-38383506-6ab4-45e5-9621-82c883c5ffb2.jpg" height="80%" width="80%">

The red shadow on the left represent the time complexity is unidirectional BFS, while the green shadow on the right represent the time complexity is bidirectional BFS. The yellow shadow represents the time complexity we saved by applying bidirectional BFS. Because we'll stop the search as soon as the two cone from both side meet each other.


Actual running time:\
![image](https://user-images.githubusercontent.com/25105806/153685668-7768d347-6e6c-42cb-b49e-fdf6f28514cf.png)
