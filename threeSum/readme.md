# 3Sum problem
* Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.
* Notice that the solution set must not contain duplicate triplets.

Leetcode link: https://leetcode.com/problems/3sum/

<br />

### Approach 1: Brute Force, threeSumBruteForce()
This the easiest solution and the also most inefficient one. Use nested loop to go through each 3-tuple combination of the numbers and check if they add up to 0. Since we use three nested for-loop, the time complexity is therefore O(n^3), which will lead to TLE(Time Limit Exceed).

```python3
def threeSumBruteForce(nums: List[int]) -> List[List[int]]:
    result = set()
    if len(nums)<3:
        return []
    else:
        for idx1, num1 in enumerate(nums):
            for idx2, num2 in enumerate(nums):
                for idx3, num3 in enumerate(nums):
                    if idx1!=idx2 and idx1!=idx3 and idx2!=idx3 and num1+num2+num3==0:
                        uniqueList = tuple(sorted(tuple((num1, num2, num3))))
                        result.add(uniqueList)
        return [list(t) for t in result]
```

<br />

### Approach 2: Generating all twoSums and store, threeSum2()
Use a O(n^2) algorithm first to generate all possible sums of two numbers and store them in a dict then go through the number list again to retrieve the desired sum using O(n) time. The time complexity is therefore O(n^2). But since this approach will also compute lots of unnecessary twoSums and store them in a dict, this will also lead to TLE.

```python3
def generateAllTwoSums(nums):
    seenAns = dict()
    sum2IndicesDict = dict()
    for idx1, num1 in enumerate(nums):
        for idx2, num2 in enumerate(nums):
            if 0-num1-num2 in nums:
                if idx1!=idx2:
                    if num1+num2 in sum2IndicesDict:
                        sum2IndicesDict[num1+num2].append((idx1, idx2))
                    else:
                        sum2IndicesDict[num1+num2] = [(idx1, idx2)]
               
    return sum2IndicesDict


def threeSum2(nums: List[int]) -> List[List[int]]:
    sum2IndicesDict = generateAllTwoSums(nums)
    result = set()
    for idx, num in enumerate(nums):
        num2IndicesList = sum2IndicesDict.get(0-num, [])
        if num2IndicesList:
            for indicesTuple in num2IndicesList:
                if idx!=indicesTuple[0] and idx!=indicesTuple[1]:
                    result.add(tuple(sorted([nums[indicesTuple[0]], nums[indicesTuple[1]], num])))
    return [list(t) for t in result]
```

<br />

### Approach 3: Generating desired twoSums on the fly, threeSumHash()
Similar to approach 2, but this time we only compute necessary twoSums instead of computing all of them and store. The details are: go through the list once and generate the desired twoSum value using O(n) time. twoSum is generated by using dict, which uses hasing to achieve constant lookup time. 

```python3
def threeSumHash(nums: List[int]) -> List[List[int]]:
    result = set()
    for idx, num in enumerate(nums):
        twoSumList = twoSumHash(nums, 0-num)
        for twoSum in twoSumList:
            if idx!=twoSum[0][1] and idx!=twoSum[1][1]:
                threeSum = tuple(sorted([twoSum[0][0], twoSum[1][0], num]))
                result.add(threeSum)

    return [list(t) for t in result]
    
    
def twoSumHash(nums, targetTwoSum):
    seenAns = set()
    resultList = list()
    mapper = dict()
    for idx, num in enumerate(nums):
        num1 = num
        num2 = targetTwoSum-num1
        if num2 not in mapper:
            mapper[num] = idx
        else:
            if num1 not in seenAns and num2 not in seenAns:
                resultList.append([(num1, idx), (num2, mapper[num2])])
                seenAns.add(num1)
                seenAns.add(num2)
    return resultList
```

The time complexity for twoSumHash() is therefore O(n). The total time complexity is therefore O(n^2)
![image](https://user-images.githubusercontent.com/25105806/119203779-c62a3a80-ba48-11eb-82e6-6ff42952bc69.png)


<br />

### Approach 4: Two Pointers, threeSumOptimal()
Turns out we can first sort the list using built-in `.sort()` function in Python, then again go through the list and use two pointers, `left` and `right` to bound the range that we take three values to check. There are three cases:
1. If the sum of current three values is smaller than 0, then that means the value pointed by `left` is too small and we should move the `left` to `left+1`.
2. If the sum of current three values is greater than 0, then that means the value pointed by `right` is too large and we should move the `right` to `right+1`.
3. If the sum of current three values is 0, then we're good.

* Note that we can use two pointers to adjust the sum of three numbers because the list is sorted, which means elements to the left are always smaller than the elements to the right.

```python3
def threeSumOptimal(nums: List[int]) -> List[List[int]]:
    result = list()
    nums.sort()
    # at least three elements in nums is needed, otherwise just return empty list
    for idx in range(len(nums)-2):
        # use two pointers to bound the range
        left = idx+1 # left pointer always start at current index + 1 so that it never visit seen elements
        right = len(nums)-1
        # if current idx=0, then there is no element before it, so no need to check
        # if current idx is not 0, then check if the element before it is same as current element, if is, skip
        if nums[idx]>0:
            # if the current value, which is also the left-most value, is greater than 0, 
            # then the remaining number must be greater than 0 as well, 
            # so there is no need to check the sum because sum of positives cannot be 0
            break
        else:
            if idx==0 or nums[idx]!=nums[idx-1]:
                while left < right:
                    # similarly, if the right-most value, which is the greatest value, is smaller than 0, 
                    # then the sum cannot be 0 as well because sum of negatives cannot be 0
                    if nums[right] < 0:
                        break
                    else:
                        if nums[idx] + nums[left] + nums[right] == 0:
                            result.append([nums[idx], nums[left], nums[right]])
                            while left<right and nums[left]==nums[left+1]: # skip duplicate elements
                                left+=1
                            while left<right and nums[right]==nums[right-1]: # skip duplicates
                                right-=1
                            left+=1 # move the left pointer to a new pos
                            right-=1 # move the right pointer to a new pos
                        elif nums[idx] + nums[left] + nums[right] < 0:
                            left+=1
                        else:
                            right-=1
    return result

```

Time complexity is O(n^2) because the sorting takes O(nlog(n)) time, the loop takes O(n^2) time.
![image](https://user-images.githubusercontent.com/25105806/119204207-b9f2ad00-ba49-11eb-8463-cc5817059055.png)
